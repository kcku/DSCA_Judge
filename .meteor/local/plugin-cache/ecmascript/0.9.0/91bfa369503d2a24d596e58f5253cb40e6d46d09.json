{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/lbee:moment-helpers/client.js","filenameRelative":"packages/lbee:moment-helpers/client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/lbee:moment-helpers/client.js.map","sourceFileName":"packages/lbee:moment-helpers/client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"client"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar MomentHelper = function () {\n  function MomentHelper() {\n    (0, _classCallCheck3.default)(this, MomentHelper);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this.args = args; // Calling this reactive property ensure the helper is updated\n\n    this.locale = mo.currentLocale.get(); // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a; // processes what was given to ensure we end up with a moment object\n\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  MomentHelper.prototype.moFormat = function () {\n    function moFormat() {\n      if (this.moDate) {\n        this.formatToken = this.args[1] || this.keywords.hash.f;\n        return this.moDate.format(mo._getToken(this.formatToken, this.moDate));\n      } // fail silently if the date is not worked out to be a moment\n\n\n      return null;\n    }\n\n    return moFormat;\n  }();\n\n  return MomentHelper;\n}();\n\nTemplate.registerHelper('moFormat', function () {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return new (Function.prototype.bind.apply(MomentHelper, [null].concat(args)))().moFormat();\n});\nTemplate.registerHelper('moDiff', function () {\n  function moDiff() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n\n    var result = void 0; // enables the arguments to be provided as args or vars\n\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var kw = args.pop();\n\n    var dateA = mo._getMoment(args[0] || kw.hash.a);\n\n    var dateB = mo._getMoment(args[1] || kw.hash.b);\n\n    var units = args[2] || kw.hash.units || 'seconds';\n    var returnFloat = args[3] || kw.hash.returnFloat; // if the returnFloat is truthy convert it to true, or falsy = false\n\n    if (returnFloat) {\n      returnFloat = true;\n    } else {\n      returnFloat = false;\n    } // if the two dates are valid moment objects, send the result\n\n\n    if (dateA && dateB) {\n      result = dateA.diff(dateB, units, returnFloat);\n    } // fail silently if the dates were not processed to a moment\n\n\n    return result;\n  }\n\n  return moDiff;\n}());\nTemplate.registerHelper('moFrom', function () {\n  function moFrom() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n\n    var result = void 0;\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    var kw = args.pop();\n\n    var dateA = mo._getMoment(args[0] || kw.hash.a);\n\n    var dateB = mo._getMoment(args[1] || kw.hash.b);\n\n    var withoutSuffix = args[2] || kw.hash.withoutSuffix; // if the withoutSuffix is truthy convert it to true, or falsy = false\n\n    if (withoutSuffix) {\n      withoutSuffix = true;\n    } else {\n      withoutSuffix = false;\n    } // if the two dates are valid moment objects, send the result\n\n\n    if (dateA && dateB) {\n      result = dateA.from(dateB, withoutSuffix);\n    } // fail silently if the dates were not processed to a moment\n\n\n    return result;\n  }\n\n  return moFrom;\n}());\nTemplate.registerHelper('moFromNow', function () {\n  function moFromNow() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n    // enables the arguments to be provided as args or vars\n\n    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    var kw = args.pop();\n    var date = args[0] || kw.hash.d;\n    var withoutSuffix = args[1] || kw.hash.withoutSuffix; // if the withoutSuffix is truthy convert it to true, or falsy = false\n\n    if (withoutSuffix) {\n      withoutSuffix = true;\n    } else {\n      withoutSuffix = false;\n    } // work with what is given to get a moment object\n\n\n    var moDate = mo._getMoment(date); // if we did end up with a valid object above, send the result\n\n\n    if (moDate) {\n      return moDate.fromNow(withoutSuffix);\n    } // fail silently if the dates were not processed to a moment\n\n\n    return null;\n  }\n\n  return moFromNow;\n}());\nTemplate.registerHelper('moCalendar', function () {\n  function moCalendar() {\n    // Calling this reactive property ensure the helper is updated\n    var locale = mo.currentLocale.get(); // eslint-disable-line\n    // enables the arguments to be provided as args or vars\n    // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n\n    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    var kw = args.pop();\n    var date = args[0] || kw.hash.d;\n    var referenceDate = args[1] || kw.hash.r;\n    var moReferenceDate = void 0; // processes what was given to ensure we end up with a moment object\n\n    var moDate = mo._getMoment(date); // never let reference date default to now if not provided\n\n\n    if (referenceDate) {\n      moReferenceDate = mo._getMoment(referenceDate);\n    } // fail silently if the date is not worked out to be a moment\n\n\n    if (moDate) {\n      if (moReferenceDate) {\n        return moDate.calendar(moReferenceDate);\n      }\n\n      return moDate.calendar();\n    }\n\n    return null;\n  }\n\n  return moCalendar;\n}());\nTemplate.registerHelper('moNow', function () {\n  return mo.now.get();\n});","map":{"version":3,"sources":["packages/lbee:moment-helpers/client.js"],"names":["MomentHelper","args","locale","mo","currentLocale","get","keywords","pop","dateA","hash","d","a","moDate","_getMoment","moFormat","formatToken","f","format","_getToken","Template","registerHelper","moDiff","result","kw","dateB","b","units","returnFloat","diff","moFrom","withoutSuffix","from","moFromNow","date","fromNow","moCalendar","referenceDate","r","moReferenceDate","calendar","now"],"mappings":"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","file":"packages/lbee:moment-helpers/client.js.map","sourcesContent":["class MomentHelper {\n\n  constructor(...args) {\n    this.args = args;\n\n    // Calling this reactive property ensure the helper is updated\n    this.locale = mo.currentLocale.get();\n\n    // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a;\n\n    // processes what was given to ensure we end up with a moment object\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  moFormat() {\n    if (this.moDate) {\n      this.formatToken = this.args[1] || this.keywords.hash.f;\n\n      return this.moDate.format(\n        mo._getToken(this.formatToken, this.moDate)\n      );\n    }\n    // fail silently if the date is not worked out to be a moment\n    return null;\n  }\n\n}\n\nTemplate.registerHelper('moFormat', (...args) =>\n  new MomentHelper(...args).moFormat()\n);\n\nTemplate.registerHelper('moDiff', function moDiff(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  const units = args[2] || kw.hash.units || 'seconds';\n  let returnFloat = args[3] || kw.hash.returnFloat;\n\n  // if the returnFloat is truthy convert it to true, or falsy = false\n  if (returnFloat) {\n    returnFloat = true;\n  } else {\n    returnFloat = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.diff(dateB, units, returnFloat);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFrom', function moFrom(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  let withoutSuffix = args[2] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.from(dateB, withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFromNow', function moFromNow(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  let withoutSuffix = args[1] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // work with what is given to get a moment object\n  const moDate = mo._getMoment(date);\n\n  // if we did end up with a valid object above, send the result\n  if (moDate) {\n    return moDate.fromNow(withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return null;\n});\n\nTemplate.registerHelper('moCalendar', function moCalendar(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  const referenceDate = args[1] || kw.hash.r;\n  let moReferenceDate;\n\n  // processes what was given to ensure we end up with a moment object\n  const moDate = mo._getMoment(date);\n\n  // never let reference date default to now if not provided\n  if (referenceDate) {\n    moReferenceDate = mo._getMoment(referenceDate);\n  }\n\n  // fail silently if the date is not worked out to be a moment\n  if (moDate) {\n    if (moReferenceDate) {\n      return moDate.calendar(moReferenceDate);\n    }\n    return moDate.calendar();\n  }\n\n  return null;\n});\n\nTemplate.registerHelper('moNow', () => mo.now.get());\n"]},"hash":"91bfa369503d2a24d596e58f5253cb40e6d46d09"}
