{"metadata":{"usedHelpers":["classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/lbee:moment-helpers/common.js","filenameRelative":"packages/lbee:moment-helpers/common.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/lbee:moment-helpers/common.js.map","sourceFileName":"packages/lbee:moment-helpers/common.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"common"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar moment = require('moment');\n\nvar MomentHelperInit = function () {\n  // let self = this;\n  //\n  function MomentHelperInit(isClient) {\n    (0, _classCallCheck3.default)(this, MomentHelperInit);\n\n    if (isClient) {\n      // create a new reactiveVar that holds the moment helper context of locale\n      this.currentLocale = new ReactiveVar(); // when creating the moment helper context, set the locale same as moment\n\n      this.currentLocale.set(moment.locale()); // reactive now\n\n      this.now = new ReactiveVar(moment());\n      var now = this.now;\n      Meteor.setInterval(function () {\n        now.set(moment());\n      }, 1000); // every second\n    } // logging messages\n\n\n    this._msg = {\n      dateNotValidReturnNow: 'valid date not provided, sending new moment instead',\n      dateNotValidReturnNull: 'valid date not provided, sending null'\n    }; // initate the default options\n\n    this.options = {\n      // if a helper is called and no date given, create one as now\n      returnNowIfDateNotGiven: false,\n      // extra console logging\n      debug: false,\n      // initial library of format tokens\n      formatTokens: {\n        'default': 'LLL' // defaults to locale date format: Month name, day of month, year, time\n\n      }\n    };\n  } // configuration function, merges the defaults with the options provided\n\n\n  MomentHelperInit.prototype.configure = function () {\n    function configure(options) {\n      _.extend(this.options, options);\n    }\n\n    return configure;\n  }(); // expose a utility to set the locale, updating moment & reactive locale\n\n\n  MomentHelperInit.prototype.setLocale = function () {\n    function setLocale(locale) {\n      moment.locale(locale);\n      this.currentLocale.set(moment.locale()); // how does 'this' work?\n    }\n\n    return setLocale;\n  }(); // logging function\n\n\n  MomentHelperInit.prototype.log = function () {\n    function log(_log) {\n      // delete the currently stored log\n      // this was enabled to assit with logging\n      delete this.logged; // if debugging is enabled, log it!\n\n      if (this.options.debug) {\n        this.logged = _log;\n        console.log(_log);\n      }\n    }\n\n    return log;\n  }(); // used for moFormat, helps to get a format token eg. 'YYYY-MM-DD'\n\n\n  MomentHelperInit.prototype._getToken = function () {\n    function _getToken(token, aMoment) {\n      check(token, Match.Optional(String, null));\n\n      var tokenLibrary = _.defaults(this.options.formatTokens, {\n        // these tokens will always be available (unless overridden)\n        'dayOfWeek': 'dddd',\n        'dayOfMonth': 'D',\n        'month': 'M',\n        'year': 'YYYY',\n        'time': 'h:mm a'\n      }); // if no token provided, use the default from the token library\n\n\n      if (!token) {\n        token = 'default';\n      } // see if the token is a reference to the token library, otherwise keep\n\n\n      token = tokenLibrary[token] || token; // check if token is a function & process\n\n      if (_.isFunction(token)) {\n        token = token.call(aMoment);\n      } // return the token\n\n\n      return token;\n    }\n\n    return _getToken;\n  }();\n\n  MomentHelperInit.prototype._getMoment = function () {\n    function _getMoment(obj) {\n      var result;\n      var date; // goal is to get a moment object from what is provided\n\n      if (moment.isMoment(obj)) {\n        // if a moment is provided, return that moment, no questions asked\n        result = obj;\n      } else if (_.isDate(obj)) {\n        // if a date is provided, convert to moment and return\n        result = moment(obj);\n      } else if (_.isString(obj) && obj.length > 1) {\n        // attempt to get a date from the string\n        // if '|' is found, separate and use the RHS as the input format token\n        if (obj.indexOf('|') !== -1) {\n          date = moment(obj.substring(0, obj.indexOf('|')), // input string LHS of '|'\n          obj.substring(obj.indexOf('|') + 1) // input format, RHS after '|'\n          );\n        } else {\n          date = moment(new Date(obj));\n        }\n\n        if (date.isValid()) {\n          result = date;\n        }\n      } // could not get a moment object, work out what to return if anything\n\n\n      if (!result) {\n        // lets support epoch as inbound date type\n        if (typeof obj === 'number') {\n          return moment.unix(obj);\n        }\n\n        if (this.options.returnNowIfDateNotGiven) {\n          this.log(this._msg.dateNotValidReturnNow);\n          return moment();\n        } else {\n          this.log(this._msg.dateNotValidReturnNull);\n        }\n      }\n\n      return result;\n    }\n\n    return _getMoment;\n  }();\n\n  return MomentHelperInit;\n}();\n\nmo = new MomentHelperInit(Meteor.isClient);","map":{"version":3,"sources":["packages/lbee:moment-helpers/common.js"],"names":["moment","require","MomentHelperInit","isClient","currentLocale","ReactiveVar","set","locale","now","Meteor","setInterval","_msg","dateNotValidReturnNow","dateNotValidReturnNull","options","returnNowIfDateNotGiven","debug","formatTokens","configure","_","extend","setLocale","log","logged","console","_getToken","token","aMoment","check","Match","Optional","String","tokenLibrary","defaults","isFunction","call","_getMoment","obj","result","date","isMoment","isDate","isString","length","indexOf","substring","Date","isValid","unix","mo"],"mappings":"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","file":"packages/lbee:moment-helpers/common.js.map","sourcesContent":["const moment = require('moment');\n\nclass MomentHelperInit {\n  // let self = this;\n\n  //\n  constructor ( isClient ) {\n\n    if ( isClient ) {\n      // create a new reactiveVar that holds the moment helper context of locale\n      this.currentLocale = new ReactiveVar();\n\n      // when creating the moment helper context, set the locale same as moment\n      this.currentLocale.set( moment.locale() );\n\n      // reactive now\n      this.now = new ReactiveVar( moment() );\n      var now = this.now;\n\n      Meteor.setInterval( function () {\n        now.set( moment() );\n      }, 1000 ); // every second\n    }\n\n    // logging messages\n    this._msg = {\n      dateNotValidReturnNow:\n        'valid date not provided, sending new moment instead',\n      dateNotValidReturnNull:\n        'valid date not provided, sending null'\n    };\n\n    // initate the default options\n    this.options = {\n      // if a helper is called and no date given, create one as now\n      returnNowIfDateNotGiven: false,\n      // extra console logging\n      debug: false,\n      // initial library of format tokens\n      formatTokens: {\n        'default': 'LLL'\n        // defaults to locale date format: Month name, day of month, year, time\n      }\n    };\n\n  }\n\n\n  // configuration function, merges the defaults with the options provided\n  configure ( options ) {\n    _.extend( this.options, options );\n  }\n\n  // expose a utility to set the locale, updating moment & reactive locale\n  setLocale ( locale ) {\n    moment.locale( locale );\n    this.currentLocale.set( moment.locale() );// how does 'this' work?\n  }\n\n  // logging function\n  log ( log ) {\n\n    // delete the currently stored log\n    // this was enabled to assit with logging\n    delete this.logged;\n\n    // if debugging is enabled, log it!\n    if ( this.options.debug ) {\n      this.logged = log;\n      console.log( log );\n    }\n  }\n\n  // used for moFormat, helps to get a format token eg. 'YYYY-MM-DD'\n  _getToken ( token, aMoment ) {\n    check( token, Match.Optional( String, null ) );\n    let tokenLibrary = _.defaults( this.options.formatTokens, {\n      // these tokens will always be available (unless overridden)\n      'dayOfWeek': 'dddd',\n      'dayOfMonth': 'D',\n      'month': 'M',\n      'year': 'YYYY',\n      'time': 'h:mm a'\n    });\n\n    // if no token provided, use the default from the token library\n    if ( !token ) {\n      token = 'default';\n    }\n\n    // see if the token is a reference to the token library, otherwise keep\n    token = tokenLibrary[token] || token;\n\n    // check if token is a function & process\n    if ( _.isFunction( token ) ) {\n      token = token.call( aMoment );\n    }\n\n    // return the token\n    return token;\n  }\n\n  _getMoment ( obj ) {\n    \n    var result;\n    var date;\n\n    // goal is to get a moment object from what is provided\n    if ( moment.isMoment( obj ) ) {\n      // if a moment is provided, return that moment, no questions asked\n        result = obj;\n    } else if ( _.isDate( obj ) ) {\n      // if a date is provided, convert to moment and return\n      result = moment( obj );\n    } else if ( _.isString( obj ) && obj.length > 1 ) {\n      // attempt to get a date from the string\n\n      // if '|' is found, separate and use the RHS as the input format token\n      if ( obj.indexOf( '|' ) !== -1 ) {\n        date = moment(\n          obj.substring( 0, obj.indexOf( '|' ) ), // input string LHS of '|'\n          obj.substring( obj.indexOf( '|' ) + 1 ) // input format, RHS after '|'\n        );\n      } else {\n        date = moment( new Date( obj ) );\n      }\n      if ( date.isValid() ) {\n        result = date;\n      }\n    }\n\n    // could not get a moment object, work out what to return if anything\n    if ( !result ) {\n      // lets support epoch as inbound date type\n      if(typeof obj === 'number'){\n        return moment.unix(obj);\n      }\n\n      if ( this.options.returnNowIfDateNotGiven ) {\n        this.log( this._msg.dateNotValidReturnNow );\n        return moment();\n      } else {\n        this.log( this._msg.dateNotValidReturnNull );\n      }\n    }\n\n    return result;\n  }\n\n}\n\nmo = new MomentHelperInit( Meteor.isClient );\n"]},"hash":"ff6acaec09e959d4a67a27677dae231876fe89b1"}
