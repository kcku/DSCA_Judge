{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/lbee:moment-helpers/client.js","filenameRelative":"packages/lbee:moment-helpers/client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/lbee:moment-helpers/client.js.map","sourceFileName":"packages/lbee:moment-helpers/client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"client"},"ignored":false,"code":"class MomentHelper {\n  constructor(...args) {\n    this.args = args; // Calling this reactive property ensure the helper is updated\n\n    this.locale = mo.currentLocale.get(); // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a; // processes what was given to ensure we end up with a moment object\n\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  moFormat() {\n    if (this.moDate) {\n      this.formatToken = this.args[1] || this.keywords.hash.f;\n      return this.moDate.format(mo._getToken(this.formatToken, this.moDate));\n    } // fail silently if the date is not worked out to be a moment\n\n\n    return null;\n  }\n\n}\n\nTemplate.registerHelper('moFormat', (...args) => new MomentHelper(...args).moFormat());\nTemplate.registerHelper('moDiff', function moDiff(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  let result; // enables the arguments to be provided as args or vars\n\n  const kw = args.pop();\n\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n\n  const units = args[2] || kw.hash.units || 'seconds';\n  let returnFloat = args[3] || kw.hash.returnFloat; // if the returnFloat is truthy convert it to true, or falsy = false\n\n  if (returnFloat) {\n    returnFloat = true;\n  } else {\n    returnFloat = false;\n  } // if the two dates are valid moment objects, send the result\n\n\n  if (dateA && dateB) {\n    result = dateA.diff(dateB, units, returnFloat);\n  } // fail silently if the dates were not processed to a moment\n\n\n  return result;\n});\nTemplate.registerHelper('moFrom', function moFrom(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  let result;\n  const kw = args.pop();\n\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n\n  let withoutSuffix = args[2] || kw.hash.withoutSuffix; // if the withoutSuffix is truthy convert it to true, or falsy = false\n\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  } // if the two dates are valid moment objects, send the result\n\n\n  if (dateA && dateB) {\n    result = dateA.from(dateB, withoutSuffix);\n  } // fail silently if the dates were not processed to a moment\n\n\n  return result;\n});\nTemplate.registerHelper('moFromNow', function moFromNow(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  // enables the arguments to be provided as args or vars\n\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  let withoutSuffix = args[1] || kw.hash.withoutSuffix; // if the withoutSuffix is truthy convert it to true, or falsy = false\n\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  } // work with what is given to get a moment object\n\n\n  const moDate = mo._getMoment(date); // if we did end up with a valid object above, send the result\n\n\n  if (moDate) {\n    return moDate.fromNow(withoutSuffix);\n  } // fail silently if the dates were not processed to a moment\n\n\n  return null;\n});\nTemplate.registerHelper('moCalendar', function moCalendar(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  // enables the arguments to be provided as args or vars\n  // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  const referenceDate = args[1] || kw.hash.r;\n  let moReferenceDate; // processes what was given to ensure we end up with a moment object\n\n  const moDate = mo._getMoment(date); // never let reference date default to now if not provided\n\n\n  if (referenceDate) {\n    moReferenceDate = mo._getMoment(referenceDate);\n  } // fail silently if the date is not worked out to be a moment\n\n\n  if (moDate) {\n    if (moReferenceDate) {\n      return moDate.calendar(moReferenceDate);\n    }\n\n    return moDate.calendar();\n  }\n\n  return null;\n});\nTemplate.registerHelper('moNow', () => mo.now.get());","map":{"version":3,"sources":["packages/lbee:moment-helpers/client.js"],"names":["MomentHelper","constructor","args","locale","mo","currentLocale","get","keywords","pop","dateA","hash","d","a","moDate","_getMoment","moFormat","formatToken","f","format","_getToken","Template","registerHelper","moDiff","result","kw","dateB","b","units","returnFloat","diff","moFrom","withoutSuffix","from","moFromNow","date","fromNow","moCalendar","referenceDate","r","moReferenceDate","calendar","now"],"mappings":"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","file":"packages/lbee:moment-helpers/client.js.map","sourcesContent":["class MomentHelper {\n\n  constructor(...args) {\n    this.args = args;\n\n    // Calling this reactive property ensure the helper is updated\n    this.locale = mo.currentLocale.get();\n\n    // eg. {{moFormat date=myDate}} / {{moFormat myDate}} will do the same thing\n    this.keywords = args.pop();\n    this.dateA = args[0] || this.keywords.hash.d || this.keywords.hash.a;\n\n    // processes what was given to ensure we end up with a moment object\n    this.moDate = mo._getMoment(this.dateA);\n  }\n\n  moFormat() {\n    if (this.moDate) {\n      this.formatToken = this.args[1] || this.keywords.hash.f;\n\n      return this.moDate.format(\n        mo._getToken(this.formatToken, this.moDate)\n      );\n    }\n    // fail silently if the date is not worked out to be a moment\n    return null;\n  }\n\n}\n\nTemplate.registerHelper('moFormat', (...args) =>\n  new MomentHelper(...args).moFormat()\n);\n\nTemplate.registerHelper('moDiff', function moDiff(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  const units = args[2] || kw.hash.units || 'seconds';\n  let returnFloat = args[3] || kw.hash.returnFloat;\n\n  // if the returnFloat is truthy convert it to true, or falsy = false\n  if (returnFloat) {\n    returnFloat = true;\n  } else {\n    returnFloat = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.diff(dateB, units, returnFloat);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFrom', function moFrom(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n  let result;\n\n  const kw = args.pop();\n  const dateA = mo._getMoment(args[0] || kw.hash.a);\n  const dateB = mo._getMoment(args[1] || kw.hash.b);\n  let withoutSuffix = args[2] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // if the two dates are valid moment objects, send the result\n  if (dateA && dateB) {\n    result = dateA.from(dateB, withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return result;\n});\n\nTemplate.registerHelper('moFromNow', function moFromNow(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  let withoutSuffix = args[1] || kw.hash.withoutSuffix;\n\n  // if the withoutSuffix is truthy convert it to true, or falsy = false\n  if (withoutSuffix) {\n    withoutSuffix = true;\n  } else {\n    withoutSuffix = false;\n  }\n\n  // work with what is given to get a moment object\n  const moDate = mo._getMoment(date);\n\n  // if we did end up with a valid object above, send the result\n  if (moDate) {\n    return moDate.fromNow(withoutSuffix);\n  }\n\n  // fail silently if the dates were not processed to a moment\n  return null;\n});\n\nTemplate.registerHelper('moCalendar', function moCalendar(...args) {\n  // Calling this reactive property ensure the helper is updated\n  const locale = mo.currentLocale.get(); // eslint-disable-line\n\n  // enables the arguments to be provided as args or vars\n  // eg. {{moFormat date=myDate}} or {{moFormat myDate}} will do the same thing\n  const kw = args.pop();\n  const date = args[0] || kw.hash.d;\n  const referenceDate = args[1] || kw.hash.r;\n  let moReferenceDate;\n\n  // processes what was given to ensure we end up with a moment object\n  const moDate = mo._getMoment(date);\n\n  // never let reference date default to now if not provided\n  if (referenceDate) {\n    moReferenceDate = mo._getMoment(referenceDate);\n  }\n\n  // fail silently if the date is not worked out to be a moment\n  if (moDate) {\n    if (moReferenceDate) {\n      return moDate.calendar(moReferenceDate);\n    }\n    return moDate.calendar();\n  }\n\n  return null;\n});\n\nTemplate.registerHelper('moNow', () => mo.now.get());\n"]},"hash":"8b233277c6b04ad1cf82f1e3f1f56fc712b87cac"}
